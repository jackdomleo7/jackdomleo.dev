import{f as w,aa as I,R as u,ab as F,ac as B,q as E,B as H,G as M,ad as P,ae as T,C as q,af as z,ag as k,J as j,ah as O,ai as G,aj as J,ak as U,al as V,am as W,an as D,i as Q,F as X,_ as Y,l as Z,o as $}from"./lFUTIujI.js";const L=(o="RouteProvider")=>w({name:o,props:{route:{type:Object,required:!0},vnode:Object,vnodeRef:Object,renderKey:String,trackRootNodes:Boolean},setup(e){const a=e.renderKey,r=e.route,t={};for(const i in e.route)Object.defineProperty(t,i,{get:()=>a===e.renderKey?e.route[i]:r[i],enumerable:!0});return I(B,F(t)),()=>e.vnode?u(e.vnode,{ref:e.vnodeRef}):e.vnode}}),ee=L(),S=new WeakMap,ne=w({name:"NuxtPage",inheritAttrs:!1,props:{name:{type:String},transition:{type:[Boolean,Object],default:void 0},keepalive:{type:[Boolean,Object],default:void 0},route:{type:Object},pageKey:{type:[Function,String],default:null}},setup(o,{attrs:e,slots:a,expose:r}){const t=E(),i=M(),l=H(B,null);let v;r({pageRef:i});const f=H(P,null);let s;const y=t.deferHydration();let p=!1,R=0;if(t.isHydrating){const n=t.hooks.hookOnce("app:error",y);T().beforeEach(n)}o.pageKey&&q(()=>o.pageKey,(n,h)=>{n!==h&&t.callHook("page:loading:start")});let d=!1;{const n=T().beforeResolve(()=>{d=!1});z(()=>{n()})}return()=>u(W,{name:o.name,route:o.route,...e},{default:n=>{const h=ae(l,n.route,n.Component),C=l&&l.matched.length===n.route.matched.length;if(!n.Component){if(s&&!C)return s;y();return}if(s&&f&&!f.isCurrent(n.route))return s;if(h&&l&&(!f||f?.isCurrent(l)))return C?s:null;const c=k(n,o.pageKey),b=oe(l,n.route,n.Component);!t.isHydrating&&v===c&&!b&&j(()=>{d||(d=!0,t.callHook("page:loading:end"))}),p&&v!==c&&R++,v=c;const g=!!(o.transition??n.route.meta.pageTransition??O),N=g&&te([o.transition,n.route.meta.pageTransition,O,{onAfterLeave(){delete t._runningTransition,t.callHook("page:transition:finish",n.Component)}}]),K=o.keepalive??n.route.meta.keepalive??G;return s=J(g&&N,U(K,u(V,{key:R,suspensible:!0,onPending:()=>{p=!0,g&&(t._runningTransition=!0),t.callHook("page:start",n.Component)},onResolve:async()=>{p=!1;try{await j(),t._route.sync?.(),await t.callHook("page:finish",n.Component),delete t._runningTransition,!d&&!b&&(d=!0,await t.callHook("page:loading:end"))}finally{y()}}},{default:()=>{const x={key:c||void 0,vnode:a.default?re(a.default,n):n.Component,route:n.route,renderKey:c||void 0,trackRootNodes:g,vnodeRef:i};if(!K)return u(ee,x);const _=n.Component.type,A=_;let m=S.get(A);return m||(m=L(_.name||_.__name),S.set(A,m)),u(m,x)}}))).default(),s}})}});function te(o){const e=[];for(const a of o)a&&e.push({...a,onAfterLeave:a.onAfterLeave?D(a.onAfterLeave):void 0});return Q(...e)}function ae(o,e,a){if(!o)return!1;const r=e.matched.findIndex(t=>t.components?.default===a?.type);return!r||r===-1?!1:e.matched.slice(0,r).some((t,i)=>t.components?.default!==o.matched[i]?.components?.default)||a&&k({route:e,Component:a})!==k({route:o,Component:a})}function oe(o,e,a){return o?e.matched.findIndex(t=>t.components?.default===a?.type)<e.matched.length-1:!1}function re(o,e){const a=o(e);return a.length===1?u(a[0]):u(X,void 0,a)}const ie={};function se(o,e){const a=ne;return $(),Z(a)}const le=Y(ie,[["render",se]]);export{le as default};
